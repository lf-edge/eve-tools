if [ $# -neq 0 ];then
    if [ "$1" = "provision_tpm" ];then
        # provision the TPM, first clear it
        tpm2_clear

        # Create Endorsement Key
        tpm2_createek -c ek.ctx
        tpm2_readpublic -c ek.ctx

        # Create Storage Root Key
        tpm2_startauthsession --policy-session -S session.ctx
        tpm2_policysecret -S session.ctx -c 0x4000000B
        tpm2_create -C ek.ctx -P "session:session.ctx" -G rsa2048 -u srk.pub -r srk.priv \
                    -a 'restricted|decrypt|fixedtpm|fixedparent|sensitivedataorigin|userwithauth'
        tpm2_flushcontext session.ctx
        tpm2_startauthsession --policy-session -S session.ctx
        tpm2_policysecret -S session.ctx -c 0x4000000B
        tpm2_load -C ek.ctx -P "session:session.ctx" -u srk.pub -r srk.priv -c srk.ctx
        tpm2_flushcontext session.ctx

        # Make persisted know-good-handles out of ek and srk
        tpm2_evictcontrol -C o -c srk.ctx 0x81000002
        tpm2 evictcontrol -C o -c ek.ctx 0x81000001

        # Clean up
        rm session.ctx ek.ctx srk.pub srk.priv srk.ctx
    fi
fi

################################### hsm_client_tpm_sign_data_succeed ###################################
# generate a hmac key
tpm2_createprimary -Q -c primary.ctx
tpm2_create -Q  -C primary.ctx -G hmac -c hmac.key

################################### hsm_client_tpm_import_key_succeed ###################################
# the tpm_import_key() is used to import a secret or key generated on a TPM to 
# another TPM. The opreation is a bit complicated, the secret is encrypted using
# a random AES key (tpm2_duplicate) then the AES key is encrypted and binded to 
# the destination TPM's SRK. This test simulate everything on one TPM.

# on dst-tpm :
# extract and send ek.pub, srk.name to the src-tpm
tpm2_readpublic -c 0x81000002 > srk.yaml
tpm2 readpublic -c 0x81000001 -o ek.pub
cat srk.yaml | grep '^name:' | awk '{ print $2 }' > srk.name

# on scr-tpm :
# generate a duplicate policy
tpm2 startauthsession -Q -S session.ctx
tpm2 policycommandcode -Q -S session.ctx -L policy.dat TPM2_CC_Duplicate
tpm2 flushcontext -Q session.ctx
rm session.ctx

# generate asymmetric key and load it into to tpm,
# this is the key we want to import to dst-tpm.
openssl genrsa -out private.pem
openssl rsa -in private.pem -out public.pem -outform PEM -pubout
tpm2 loadexternal -Q -G rsa -C n -r private.pem -c key.ctx -L policy.dat
tpm2 readpublic -Q -c key.ctx -o dup.pub
tpm2 readpublic -Q -c key.ctx -f tpmt -o dup.pub.tpmt

# start a session
tpm2 startauthsession -Q --policy-session -S session.ctx
tpm2 policycommandcode -Q -S session.ctx -L policy.dat TPM2_CC_Duplicate

# duplicate the imported key (it will get encrypted with the sym.key AES key 
# which is randomly generated by the TPM) and then send dup.dup, dup.seed and 
# to the dst-tpm.
tpm2 duplicate -Q -C null -c key.ctx -G aes -o sym.key -p "session:session.ctx" -r dup.dup -s dup.seed

# encrypt the aes key using dst-tpm ek.pub, srk.name and send sym.key.encrypted 
# to the dst-tpm.
tpm2_makecredential -Q -T none -e ek.pub -s sym.key -n $(cat srk.name) -o sym.key.encrypted

# make the binary input blob for the test
dd skip=8 count=$(stat -c %s sym.key.encrypted) if=sym.key.encrypted of=insert_key.bin bs=1

# don't need to insert size before the struct, insert_key_in_tpm will marshal the struct
# and extracts the size.
cat dup.dup >> insert_key.bin

# don't need to insert size before the struct, insert_key_in_tpm will marshal the struct
# and extracts the size.
cat dup.seed >> insert_key.bin

printf "%04x" $(stat -c %s dup.pub.tpmt) | fold -w2 | tr -d "\n" | xxd -r -p >> insert_key.bin
cat dup.pub.tpmt >> insert_key.bin

# end the session
tpm2 flushcontext -Q session.ctx
rm session.ctx

# run the test
./bin/tpm_tests

# final clean up
tpm2_flushcontext -t -l -s
rm primary.ctx hmac.key srk.yaml ek.pub srk.name policy.dat private.pem key.ctx \
dup.pub dup.pub.tpmt sym.key dup.dup dup.seed insert_key.bin public.pem sym.key.encrypted

